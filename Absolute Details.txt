Comprehensive Summary of the Photo Sharing System

This system is designed to streamline the collection of photos taken by guests, storing them securely and organized for the event organizers. It leverages a serverless architecture on AWS for scalability, reliability, and cost-effectiveness (aiming for the free tier).

1. Core Goal:

The fundamental purpose is to provide a simple, guest-friendly interface for photo uploads directly from their mobile devices while ensuring these photos are centrally and securely collected and organized for the hosts. The key constraint is to limit uploads to a specific number (e.g., 10) per device, per event, to prevent a single guest or device from overwhelming the system, even if they try to bypass client-side restrictions.



2. The User Journey:

A guest scans a QR code, which directs their mobile browser to a simple web application.

Initial Access: The web page loads (from S3).

Identification & Device Recognition: The guest enters their name. Crucially, the browser also checks its local storage for a unique DeviceID associated with the current event. If not found, a new one is generated and stored. Both the guest's name and this DeviceID are stored locally for the duration of their session for this event.

Photo Capture & Review: The guest uses the web app to take photos via their phone's camera, reviewing each one.

Upload Decision: For each photo, they can save it locally, discard it, or choose to upload it.

Upload and Limit Check (Server-Side): When "Upload" is selected, the photo data, along with the guest's name, EventName, and the unique DeviceID, is sent to a server endpoint (API Gateway).

Server Processing & Storage: The server receives the request. Before saving the photo, it checks the upload count for that specific DeviceID and EventName in a database (DynamoDB).If the count is less than the limit (e.g., 10), the server increments the count in DynamoDB and proceeds to save the photo to cloud storage (S3).

If the count has reached the limit, the server rejects the upload and sends an error back to the browser.

Client Feedback: The web app on the guest's phone receives the response. If successful, it updates the local photo count (primarily for immediate UI feedback) and may show a success message. If the upload is rejected due to the limit, it displays a clear message to the guest.

Organizer Access: After the event, organizers can access the stored photos in S3, which are conveniently organized by event and guest name.



3. Key Components (AWS Services) and Their Roles

Amazon S3 (Simple Storage Service): 
Acts as the primary storage layer.Public S3 Bucket: Serves the static website files (HTML, CSS, JavaScript) that guests access via the QR code. Configured for public read access.

Private S3 Bucket: 
Securely stores the uploaded photos. Configured for private access, accessible only by authorized AWS services (like Lambda). Photos are organized using folders like EventName/GuestName/.

AWS IAM (Identity and Access Management): 
Manages permissions within your AWS account.A specific IAM Role is created and assigned to the Lambda function. This role grants Lambda the necessary permissions to:Write (put objects) to the private S3 bucket.
Read and Update items in the DynamoDB table (specifically the dynamodb:UpdateItem action).

AWS Lambda: 
The serverless compute service that runs the backend code in response to events.
The Python code in Lambda is triggered by incoming requests from API Gateway.
It receives the upload data (photo, guest name, event name, device ID).
It interacts with DynamoDB to check and atomically increment the photo count for the given EventName and DeviceID, using a conditional write to enforce the limit (UploadCount < 10).
Only if the DynamoDB update succeeds (meaning the limit was not reached), it then uploads the photo data to the private S3 bucket using the permissions granted by the IAM role.
It returns a response to the client (success or a 429 error if the limit was reached).

Amazon API Gateway:
Acts as the secure front door for the Lambda function.Provides a public HTTP endpoint that the client-side JavaScript calls to initiate an upload.
Forwards incoming requests to the configured Lambda function.
Handles aspects like request routing, potentially authentication (though not used in this simple setup), and ensuring CORS headers are correctly configured so the website from the public S3 bucket can communicate with the API endpoint.

Amazon DynamoDB: 
A fast, flexible NoSQL database service.Stores the persistent state for tracking photo uploads per device, per event.
Uses EventName as the Partition Key and DeviceID as the Sort Key to uniquely identify each device's count within a specific event.
The Lambda function uses DynamoDB's UpdateItem with an atomic counter (ADD UploadCount :inc) and a ConditionExpression (attribute_not_exists(DeviceID) OR UploadCount < :max) to safely increment the count only if the limit hasn't been reached.



4. How They Work Together (The Flow of Data - Integrated):

Guest Access: Guest scans QR code pointing to the Public S3 Bucket URL.
Website Load: Browser loads index.html, style.css, and app.js from the Public S3 Bucket.
Initial Setup: app.js runs. It gets the EventName (from HTML or default), sets local storage keys based on the event, and calls ensureDeviceID().
Device ID Management (ensureDeviceID()): app.js checks localStorage for a DeviceID using the event-specific key (STORAGE_KEY_PREFIX + EventName + '_deviceID'). If not found, it generates a new UUID and saves it to localStorage. This DeviceID persists in the browser unless the user manually clears localStorage for the site.
Name Input & State Load: Guest enters their name. app.js loads the name and the local photo count for this event (using event-specific keys) from localStorage. The UI updates.
Photo Taken: Guest uses the camera/file input via the web app.
Upload Triggered: Guest clicks "Upload". app.js prepares the photo data (Base64), guestName, eventName, and deviceID.
Request to API Gateway: app.js sends a POST request with this data to the API Gateway endpoint (API_ENDPOINT).
API Gateway to Lambda: API Gateway receives the request and invokes the configured Lambda function.
Lambda Processing - DynamoDB Check (NEW): The Lambda function starts executing. It first attempts to update the item in the PhotoUploadCounts DynamoDB table using EventName and DeviceID.It tries to ADD 1 to the UploadCount.
The ConditionExpression attribute_not_exists(DeviceID) OR UploadCount < 10 is evaluated by DynamoDB before the write happens.
Limit Enforcement:If the condition passes (either it's the first upload for this device/event, or the current count is less than 10), DynamoDB increments the count and the update succeeds. Lambda receives the new count.
If the condition fails (the count was already 10 or more for this device/event), DynamoDB rejects the update with a ConditionalCheckFailedException.
S3 Upload (Conditional):If the DynamoDB update succeeded, Lambda proceeds to decode the image data and upload it to the Private S3 Bucket, creating a path like EventName/GuestName/timestamp_uuid.jpg.
If the DynamoDB update failed due to the condition, Lambda skips the S3 upload and prepares a response with a 429 (Too Many Requests) status code and an explanatory message.
Response to Client: Lambda returns the HTTP response (200 for success, 429 for limit reached, 500 for other errors) through API Gateway back to the guest's browser.
Client UI Update: app.js receives the response.If 200: Updates the local photoCount based on the returned count from Lambda (if available) or increments locally. Clears the current photo preview and updates the UI (back to camera view, potentially showing success).
If 429: Sets the local photoCount to MAX_PHOTOS, saves state, clears the photo preview, and updates the UI to show the limit-reached-section.
If other error: Displays an error message.

Post-Event Access: Organizers directly access the Private S3 Bucket (using separate credentials or methods not part of the guest flow) to retrieve all photos, which are neatly organized by event and guest.

5. Key Concepts:

Modularity: Components (S3, IAM, Lambda, API Gateway, DynamoDB) are independent services with specific roles.
Event-Driven Architecture: Lambda is triggered by the API Gateway HTTP request event. DynamoDB updates are the result of the Lambda execution, not independent triggers in this flow.
Serverless: No servers to provision or manage for Lambda, API Gateway, S3, or DynamoDB. Scaling is handled automatically by AWS.
Client-Side vs. Server-Side: The browser runs the interactive web app (client-side). Lambda and DynamoDB run on AWS (server-side). The critical state management and limit enforcement (UploadCount) have been moved to the server-side (DynamoDB + Lambda logic).
Permissions and Security: IAM ensures only Lambda can write to the private S3 bucket and update the DynamoDB table. API Gateway provides a controlled entry point.
CORS: Required to allow the JavaScript from the S3-hosted website to make requests to the API Gateway domain.
Server-Side State Management (NEW): DynamoDB is introduced to maintain the persistent state of photo counts per device per event, overcoming the statelessness of Lambda and the ephemeral nature of browser storage.
Atomic Counters & Conditional Writes (DynamoDB): Used to safely and reliably increment the count only if the limit hasn't been reached, preventing race conditions and enforcing the limit server-side.

